-- XGEN: Autogenerated File

library IEEE;
library UNISIM;
use IEEE.numeric_std.all;
use IEEE.std_logic_1164.all;
use UNISIM.VComponents.all;
use ieee.std_logic_unsigned.all;
use work.xgen_klm_scrod_bus.all;

package xgen_serialdatarout_p is 

constant Bitwidth : integer := 15;

  type SerialDataRout_s_state is ( 
    idle,
    sampleSelect,
    clock_out_data,
    received_data
  );

-------------------------------------------------------------------------
------- Start Psuedo Class SerialDataConfig -------------------------

type SerialDataConfig is record 
  column_select : std_logic_vector(5 downto 0); 
  sample_stop : std_logic_vector(4 downto 0); 
  force_test_pattern : std_logic; 
  row_Select : std_logic_vector(2 downto 0); 
  sample_start : std_logic_vector(4 downto 0); 
  ASIC_NUM : std_logic_vector(3 downto 0); 
end record;


constant SerialDataConfig_null : SerialDataConfig:= (
  column_select => (others => '0'),
  sample_stop => (others => '0'),
  force_test_pattern => '0',
  row_Select => (others => '0'),
  sample_start => (others => '0'),
  ASIC_NUM => (others => '0')
);


type SerialDataConfig_a is array (natural range <>) of SerialDataConfig;


procedure serialize ( dataIn : inout STD_LOGIC_VECTOR; BitCounter : inout integer;  data_out : inout std_logic_vector(31 downto 0));
procedure serialize ( dataIn : inout STD_LOGIC; BitCounter : inout integer;  data_out : inout std_logic_vector(31 downto 0));

procedure serialize ( self : inout SerialDataConfig ; data_out : inout std_logic_vector(31 downto 0));



procedure deserialize ( dataIn : inout STD_LOGIC_VECTOR; BitCounter : inout integer;  data_out : inout std_logic_vector(31 downto 0));
procedure deserialize ( dataIn : inout STD_LOGIC; BitCounter : inout integer;  data_out : inout std_logic_vector(31 downto 0));

procedure deserialize ( self : inout SerialDataConfig ; data_out : inout std_logic_vector(31 downto 0));
------- End Psuedo Class SerialDataConfig -------------------------
-------------------------------------------------------------------------


-------------------------------------------------------------------------
------- Start Psuedo Class readOutConfig -------------------------

type readOutConfig is record 
  sr_select_stop : std_logic_vector(7 downto 0); 
  sr_clk_Period : std_logic_vector(7 downto 0); 
  sr_clk_stop : std_logic_vector(7 downto 0); 
  sr_select_done : std_logic_vector(7 downto 0); 
  sr_select_start : std_logic_vector(7 downto 0); 
  sr_clk_High : std_logic_vector(7 downto 0); 
  sr_clk_start : std_logic_vector(7 downto 0); 
end record;


constant readOutConfig_null : readOutConfig:= (
  sr_select_stop => x"10",
  sr_clk_Period => x"09",
  sr_clk_stop => x"09",
  sr_select_done => x"14",
  sr_select_start => x"04",
  sr_clk_High => x"04",
  sr_clk_start => x"06"
);


type readOutConfig_a is array (natural range <>) of readOutConfig;

------- End Psuedo Class readOutConfig -------------------------
-------------------------------------------------------------------------


-------------------------------------------------------------------------
------- Start Psuedo Class SerialDataRout_s -------------------------

type SerialDataRout_s is record 
  RO_Config : readOutConfig; 
  sr_counter_max : std_logic_vector(7 downto 0); 
  rx : TXShiftRegisterSignals; 
  counter : std_logic_vector(7 downto 0); 
  state : SerialDataRout_s_state; 
  AsicN : integer; 
  sr_counter : std_logic_vector(7 downto 0); 
  sr_dataRead : std_logic; 
end record;


constant SerialDataRout_s_null : SerialDataRout_s:= (
  RO_Config => readOutConfig_null,
  sr_counter_max => x"0c",
  rx => TXShiftRegisterSignals_null,
  counter => (others => '0'),
  state => idle,
  AsicN => 0,
  sr_counter => (others => '0'),
  sr_dataRead => '0'
);


type SerialDataRout_s_a is array (natural range <>) of SerialDataRout_s;

  procedure pull ( self : inout SerialDataRout_s;  signal rx :  in  TXShiftRegisterSignals_m2s);
  procedure push ( self : inout SerialDataRout_s;  signal rx :  out  TXShiftRegisterSignals_s2m);
  procedure request_sample (self : inout SerialDataRout_s; req_sample :  in  std_logic_vector(4 downto 0); AsicN :  in  std_logic_vector(3 downto 0));
  procedure request_test_Pattern (self : inout SerialDataRout_s; AsicN :  in  std_logic_vector(3 downto 0));
  function isReadyToRequestSample (  self : SerialDataRout_s) return boolean;
  function isReceiving (  self : SerialDataRout_s) return boolean;
  function isEndOfStream (  self : SerialDataRout_s) return boolean;
  procedure read_data (self : inout SerialDataRout_s; data_out :  out  std_logic_vector(15 downto 0));
------- End Psuedo Class SerialDataRout_s -------------------------
-------------------------------------------------------------------------


-------------------------------------------------------------------------
------- Start Psuedo Class TX_timeSpan -------------------------

type TX_timeSpan is record 
  Stop : std_logic_vector(15 downto 0); 
  Start : std_logic_vector(15 downto 0); 
end record;


constant TX_timeSpan_null : TX_timeSpan:= (
  Stop => (others => '0'),
  Start => (others => '0')
);


type TX_timeSpan_a is array (natural range <>) of TX_timeSpan;

------- End Psuedo Class TX_timeSpan -------------------------
-------------------------------------------------------------------------


-------------------------------------------------------------------------
------- Start Psuedo Class TX_SamplingControls -------------------------

type TX_SamplingControls is record 
  RD_ROWSEL_S : std_logic_vector(2 downto 0); 
  RAMP : std_logic; 
  WR_ADDRCLR : std_logic; 
  RD_COLSEL_S : std_logic_vector(5 downto 0); 
  RD_ENA : std_logic; 
  CLR : std_logic; 
end record;


constant TX_SamplingControls_null : TX_SamplingControls:= (
  RD_ROWSEL_S => (others => '0'),
  RAMP => '0',
  WR_ADDRCLR => '0',
  RD_COLSEL_S => (others => '0'),
  RD_ENA => '0',
  CLR => '0'
);


type TX_SamplingControls_a is array (natural range <>) of TX_SamplingControls;

------- End Psuedo Class TX_SamplingControls -------------------------
-------------------------------------------------------------------------


-------------------------------------------------------------------------
------- Start Psuedo Class TX_SamplingConfigs -------------------------

type TX_SamplingConfigs is record 
  RD_ROWSEL_S : TX_timeSpan; 
  RAMP : TX_timeSpan; 
  WR_ADDRCLR : TX_timeSpan; 
  RD_COLSEL_S : TX_timeSpan; 
  RD_ENA : TX_timeSpan; 
  CLR : TX_timeSpan; 
end record;


constant TX_SamplingConfigs_null : TX_SamplingConfigs:= (
  RD_ROWSEL_S => TX_timeSpan_null,
  RAMP => TX_timeSpan_null,
  WR_ADDRCLR => TX_timeSpan_null,
  RD_COLSEL_S => TX_timeSpan_null,
  RD_ENA => TX_timeSpan_null,
  CLR => TX_timeSpan_null
);


type TX_SamplingConfigs_a is array (natural range <>) of TX_SamplingConfigs;

------- End Psuedo Class TX_SamplingConfigs -------------------------
-------------------------------------------------------------------------


end xgen_serialdatarout_p;


package body xgen_serialdatarout_p is

-------------------------------------------------------------------------
------- Start Psuedo Class SerialDataConfig -------------------------
------- End Psuedo Class SerialDataConfig -------------------------
  -------------------------------------------------------------------------

  procedure serialize ( dataIn : inout STD_LOGIC_VECTOR; BitCounter : inout integer;  data_out : inout std_logic_vector(31 downto 0))is
    
    
  begin

    data_out( BitCounter + dataIn'length -1  downto BitCounter ) := dataIn; 
    BitCounter := BitCounter + dataIn'length;


  end procedure;
  
  procedure serialize ( dataIn : inout STD_LOGIC; BitCounter : inout integer;  data_out : inout std_logic_vector(31 downto 0))is


  begin

    data_out( BitCounter ) := dataIn; 
    BitCounter := BitCounter + 1;


  end procedure;
procedure serialize ( self : inout SerialDataConfig ; data_out : inout std_logic_vector(31 downto 0)) is 

  variable BitCounter : integer := 0;
begin
  serialize(self.row_Select,         BitCounter, data_out);
  serialize(self.column_select,      BitCounter, data_out);
  serialize(self.ASIC_NUM,           BitCounter, data_out);
  serialize(self.sample_start,       BitCounter, data_out);
  serialize(self.sample_stop,        BitCounter, data_out);
  serialize(self.force_test_pattern, BitCounter, data_out);
  
end procedure;

procedure deserialize ( dataIn : inout STD_LOGIC_VECTOR; BitCounter : inout integer;  data_out : inout std_logic_vector(31 downto 0)) is 
  
begin 
  dataIn  := data_out(BitCounter + dataIn'length -1  downto BitCounter);
  BitCounter := BitCounter+dataIn'length;

end procedure;

procedure deserialize ( dataIn : inout STD_LOGIC; BitCounter : inout integer;  data_out : inout std_logic_vector(31 downto 0))is 
begin
  dataIn  := data_out(BitCounter);
  BitCounter := BitCounter+1;
end procedure;

procedure deserialize ( self : inout SerialDataConfig ; data_out : inout std_logic_vector(31 downto 0)) is 
  variable BitCounter : integer := 0;
begin
  deserialize(self.row_Select,         BitCounter, data_out);
  deserialize(self.column_select,      BitCounter, data_out);
  deserialize(self.ASIC_NUM,           BitCounter, data_out);
  deserialize(self.sample_start,       BitCounter, data_out);
  deserialize(self.sample_stop,        BitCounter, data_out);
  deserialize(self.force_test_pattern, BitCounter, data_out);

end procedure;

-------------------------------------------------------------------------
------- Start Psuedo Class readOutConfig -------------------------
------- End Psuedo Class readOutConfig -------------------------
  -------------------------------------------------------------------------


-------------------------------------------------------------------------
------- Start Psuedo Class SerialDataRout_s -------------------------
procedure pull (  self : inout SerialDataRout_s;  signal rx :  in  TXShiftRegisterSignals_m2s) is
   
  begin 
 
    
-- Start Connecting
    
  pull_rev( self.rx, rx);

-- End Connecting
    self.counter := self.counter + 1;
  self.rx.sr_select := '0';
  self.rx.sr_Clock :=  (others => '0');
  self.sr_dataRead := '0';
  
    if (self.state = sampleSelect) then 
      
      if (( self.counter >= self.RO_Config.sr_select_start and self.counter <= self.RO_Config.sr_select_stop) ) then 
        self.rx.sr_select := '1';
        
      end if;
      
      if (( self.counter >= self.RO_Config.sr_clk_start and self.counter <= self.RO_Config.sr_clk_stop) ) then 
        self.rx.sr_Clock(self.AsicN) := '1';
        
      end if;
      
      if (self.counter >= self.RO_Config.sr_select_done) then 
        self.state := clock_out_data;
        self.counter := self.RO_Config.sr_clk_High;
        
      end if;
      
    elsif (self.state = clock_out_data) then 
      self.rx.SampleSelectAny(self.AsicN) := '1';
      
      if (self.counter < self.RO_Config.sr_clk_High) then 
        self.rx.sr_Clock(self.AsicN) := '1';
        
      elsif (self.counter >= self.RO_Config.sr_clk_Period) then 
        self.state := received_data;
        
    end if;
    
  end if;
  
             
end procedure;

procedure push (  self : inout SerialDataRout_s;  signal rx :  out  TXShiftRegisterSignals_s2m) is
   
  begin 
 
    
  if (self.sr_dataRead = '1') then 
  self.sr_counter := self.sr_counter + 1;
  self.state := clock_out_data;
  self.counter :=  (others => '0');
  
  end if;
  
  if (self.sr_counter > self.sr_counter_max) then 
  self.state := idle;
  self.sr_counter :=  (others => '0');
  self.rx.SampleSelect :=  (others => '0');
  self.rx.SampleSelectAny :=  (others => '0');
  
  end if;
  
-- Start Connecting
    
  push_rev( self.rx, rx);

-- End Connecting
    
             
end procedure;

procedure request_sample ( self : inout SerialDataRout_s; req_sample :  in  std_logic_vector(4 downto 0); AsicN :  in  std_logic_vector(3 downto 0)) is
   
  begin 
 self.rx.SampleSelect := req_sample;
  self.AsicN := to_integer(unsigned(AsicN)); 
  self.rx.SampleSelectAny(self.AsicN) := '1';
  self.counter :=  (others => '0');
  self.sr_counter :=  (others => '0');
  self.state := sampleSelect;
   
end procedure;

procedure request_test_Pattern ( self : inout SerialDataRout_s; AsicN :  in  std_logic_vector(3 downto 0)) is
   
  begin 
 self.AsicN :=  to_integer(unsigned(AsicN)); 
  self.counter :=  (others => '0');
  self.sr_counter :=  (others => '0');
  self.state := sampleSelect;
   
end procedure;

function isReadyToRequestSample (  self : SerialDataRout_s) return boolean is
   
  begin 
 return self.state = idle;
   
end function;

function isReceiving (  self : SerialDataRout_s) return boolean is
   
  begin 
 return self.state = received_data;
   
end function;

function isEndOfStream (  self : SerialDataRout_s) return boolean is
   
  begin 
 return ( isReceiving(self) and self.sr_counter = self.sr_counter_max) ;
   
end function;

procedure read_data ( self : inout SerialDataRout_s; data_out :  out  std_logic_vector(15 downto 0)) is
   
  begin 
 data_out := self.rx.data_out;
  self.sr_dataRead := '1';
   
end procedure;

------- End Psuedo Class SerialDataRout_s -------------------------
  -------------------------------------------------------------------------


-------------------------------------------------------------------------
------- Start Psuedo Class TX_timeSpan -------------------------
------- End Psuedo Class TX_timeSpan -------------------------
  -------------------------------------------------------------------------


-------------------------------------------------------------------------
------- Start Psuedo Class TX_SamplingControls -------------------------
------- End Psuedo Class TX_SamplingControls -------------------------
  -------------------------------------------------------------------------


-------------------------------------------------------------------------
------- Start Psuedo Class TX_SamplingConfigs -------------------------
------- End Psuedo Class TX_SamplingConfigs -------------------------
  -------------------------------------------------------------------------


end xgen_serialdatarout_p;