-- XGEN: Autogenerated File

library IEEE;
library UNISIM;
  use IEEE.numeric_std.all;
  use IEEE.std_logic_1164.all;
  use UNISIM.VComponents.all;
  use ieee.std_logic_unsigned.all;


package clk_domain_crossing is 

  -------------------------------------------------------------------------
  ------- Start Psuedo Class clk_domain_crossing -------------------------

  type clk_domain_crossing_m2s is record 
    DoneReceived : std_logic; 
    data : std_logic_vector(31 downto 0); 
    isValid : std_logic; 
  end record;


  constant clk_domain_crossing_m2s_null : clk_domain_crossing_m2s:= (
    DoneReceived => '0',
    data => (others => '0'),
    isValid => '0'
  );


  type clk_domain_crossing_m2s_a is array (natural range <>) of clk_domain_crossing_m2s;




  type clk_domain_crossing_s2m is record 
    isDone : std_logic; 
  end record;


  constant clk_domain_crossing_s2m_null : clk_domain_crossing_s2m:= (
    isDone => '0'
  );


  type clk_domain_crossing_s2m_a is array (natural range <>) of clk_domain_crossing_s2m;




  type clk_domain_crossing is record 
    isDone : std_logic; 
    DoneReceived : std_logic; 
    data : std_logic_vector(31 downto 0); 
    isValid : std_logic; 
  end record;


  constant clk_domain_crossing_null : clk_domain_crossing:= (
    isDone => '0',
    DoneReceived => '0',
    data => (others => '0'),
    isValid => '0'
  );


  type clk_domain_crossing_a is array (natural range <>) of clk_domain_crossing;

  procedure pull_rev ( self : inout clk_domain_crossing;  signal DoneReceived :  in  std_logic; signal data :  in  std_logic_vector(31 downto 0); signal isValid :  in  std_logic);
  procedure pull ( self : inout clk_domain_crossing; signal dataIn :  in clk_domain_crossing_s2m);
  procedure pull ( self : inout clk_domain_crossing;  signal isDone :  in  std_logic);
  procedure push_rev ( self : inout clk_domain_crossing;  signal isDone :  out  std_logic);
  procedure push_rev ( self : inout clk_domain_crossing; signal dataOut :  out clk_domain_crossing_s2m);
  procedure pull_rev ( self : inout clk_domain_crossing; signal dataIn :  in clk_domain_crossing_m2s);
  procedure push ( self : inout clk_domain_crossing;  signal DoneReceived :  out  std_logic; signal data :  out  std_logic_vector(31 downto 0); signal isValid :  out  std_logic);
  procedure push ( self : inout clk_domain_crossing; signal dataOut :  out clk_domain_crossing_m2s);
  ------- End Psuedo Class clk_domain_crossing -------------------------
  -------------------------------------------------------------------------


  -------------------------------------------------------------------------
  ------- Start Psuedo Class clk_domain_crossing_master -------------------------

  type clk_domain_crossing_master is record 
    tx : clk_domain_crossing; 
  end record;


  constant clk_domain_crossing_master_null : clk_domain_crossing_master:= (
    tx => clk_domain_crossing_null
  );


  type clk_domain_crossing_master_a is array (natural range <>) of clk_domain_crossing_master;

  procedure push ( self : inout clk_domain_crossing_master;  signal tx :  out  clk_domain_crossing_m2s);
  procedure pull ( self : inout clk_domain_crossing_master;  signal tx :  in  clk_domain_crossing_s2m);
  function isReady (  self : clk_domain_crossing_master) return boolean;
  procedure sendData (self : inout clk_domain_crossing_master; data :  in  std_logic_vector(31 downto 0));
  ------- End Psuedo Class clk_domain_crossing_master -------------------------
  -------------------------------------------------------------------------


  -------------------------------------------------------------------------
  ------- Start Psuedo Class clk_domain_crossing_slave -------------------------

  type clk_domain_crossing_slave is record 
    rx : clk_domain_crossing; 
  end record;


  constant clk_domain_crossing_slave_null : clk_domain_crossing_slave:= (
    rx => clk_domain_crossing_null
  );


  type clk_domain_crossing_slave_a is array (natural range <>) of clk_domain_crossing_slave;

  procedure pull ( self : inout clk_domain_crossing_slave;  signal rx :  in  clk_domain_crossing_m2s);
  procedure push ( self : inout clk_domain_crossing_slave;  signal rx :  out  clk_domain_crossing_s2m);
  function isReady (  self : clk_domain_crossing_slave) return boolean;
  procedure ReadData (self : inout clk_domain_crossing_slave; DataOut :  out  std_logic_vector(31 downto 0));
  ------- End Psuedo Class clk_domain_crossing_slave -------------------------
  -------------------------------------------------------------------------


end clk_domain_crossing;


package body clk_domain_crossing is

  -------------------------------------------------------------------------
  ------- Start Psuedo Class clk_domain_crossing -------------------------
  procedure pull_rev (  self : inout clk_domain_crossing;  signal DoneReceived :  in  std_logic; signal data :  in  std_logic_vector(31 downto 0); signal isValid :  in  std_logic) is

  begin 


    -- Start Connecting

    self.DoneReceived := DoneReceived;
    self.data := data;
    self.isValid := isValid;

    -- End Connecting


  end procedure;

  procedure pull (  self : inout clk_domain_crossing; signal dataIn :  in clk_domain_crossing_s2m) is

  begin 


    -- Start Connecting

    self.isDone := dataIn.isDone;

    -- End Connecting


  end procedure;

  procedure pull (  self : inout clk_domain_crossing;  signal isDone :  in  std_logic) is

  begin 


    -- Start Connecting

    self.isDone := isDone;

    -- End Connecting


  end procedure;

  procedure push_rev (  self : inout clk_domain_crossing;  signal isDone :  out  std_logic) is

  begin 


    -- Start Connecting

    isDone <=  self.isDone;

    -- End Connecting


  end procedure;

  procedure push_rev (  self : inout clk_domain_crossing; signal dataOut :  out clk_domain_crossing_s2m) is

  begin 


    -- Start Connecting

    dataOut.isDone <=  self.isDone;

    -- End Connecting


  end procedure;

  procedure pull_rev (  self : inout clk_domain_crossing; signal dataIn :  in clk_domain_crossing_m2s) is

  begin 


    -- Start Connecting

    self.DoneReceived := dataIn.DoneReceived;
    self.data := dataIn.data;
    self.isValid := dataIn.isValid;

    -- End Connecting


  end procedure;

  procedure push (  self : inout clk_domain_crossing;  signal DoneReceived :  out  std_logic; signal data :  out  std_logic_vector(31 downto 0); signal isValid :  out  std_logic) is

  begin 


    -- Start Connecting

    DoneReceived <=  self.DoneReceived;
    data <=  self.data;
    isValid <=  self.isValid;

    -- End Connecting


  end procedure;

  procedure push (  self : inout clk_domain_crossing; signal dataOut :  out clk_domain_crossing_m2s) is

  begin 


    -- Start Connecting

    dataOut.DoneReceived <=  self.DoneReceived;
    dataOut.data <=  self.data;
    dataOut.isValid <=  self.isValid;

    -- End Connecting


  end procedure;

  ------- End Psuedo Class clk_domain_crossing -------------------------
  -------------------------------------------------------------------------


  -------------------------------------------------------------------------
  ------- Start Psuedo Class clk_domain_crossing_master -------------------------
  procedure push (  self : inout clk_domain_crossing_master;  signal tx :  out  clk_domain_crossing_m2s) is

  begin 


    -- Start Connecting

    push( self.tx, tx);

    -- End Connecting


  end procedure;

  procedure pull (  self : inout clk_domain_crossing_master;  signal tx :  in  clk_domain_crossing_s2m) is

  begin 


    -- Start Connecting

    pull( self.tx, tx);

    -- End Connecting

    if (self.tx.isDone = '1') then 
      self.tx.DoneReceived := '1';

    end if;

    if (( self.tx.DoneReceived = '1' and  not  ( self.tx.isDone = '1' ) )) then 
      self.tx.DoneReceived := '0';
      self.tx.isValid := '0';

    end if;


  end procedure;

  function isReady (  self : clk_domain_crossing_master) return boolean is

  begin 
    return self.tx.isValid = '0';

  end function;

  procedure sendData ( self : inout clk_domain_crossing_master; data :  in  std_logic_vector(31 downto 0)) is

  begin 

    if (isReady(self)) then 
      self.tx.isValid := '1';
      self.tx.data := data;

    end if;

  end procedure;

  ------- End Psuedo Class clk_domain_crossing_master -------------------------
  -------------------------------------------------------------------------


  -------------------------------------------------------------------------
  ------- Start Psuedo Class clk_domain_crossing_slave -------------------------
  procedure pull (  self : inout clk_domain_crossing_slave;  signal rx :  in  clk_domain_crossing_m2s) is

  begin 


    -- Start Connecting

    pull_rev( self.rx, rx);

    -- End Connecting

    if (self.rx.DoneReceived = '1') then 
      self.rx.isDone := '0';

    end if;


  end procedure;

  procedure push (  self : inout clk_domain_crossing_slave;  signal rx :  out  clk_domain_crossing_s2m) is

  begin 


    -- Start Connecting

    push_rev( self.rx, rx);

    -- End Connecting


  end procedure;

  function isReady (  self : clk_domain_crossing_slave) return boolean is

  begin 
    return ( self.rx.isValid = '1' and  not  ( self.rx.isDone = '1' ) ) and not self.rx.DoneReceived = '1';

  end function;

  procedure ReadData ( self : inout clk_domain_crossing_slave; DataOut :  out  std_logic_vector(31 downto 0)) is

  begin 
    self.rx.isDone := '1';
    DataOut := self.rx.data;

  end procedure;

  ------- End Psuedo Class clk_domain_crossing_slave -------------------------
  -------------------------------------------------------------------------


end clk_domain_crossing;